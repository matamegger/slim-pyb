# SliM Pyb
Python framework to generate binaries and Python bindings for Simulink Models.
___

## Motivation
MathWorks Simulink is a great tool setup and simulate dynamical systems as well as the according control systems. The convenience of the graphical interface and the possibilities of the MatLab code and engine behind it, contributed to a wide popularity of the tool set.
Unfortunately, the proprietary closed system does not allow for a big community and in case of missing tools or functionality one has to wait until MathWorks provides the according tools.

Python is a widely known programming language, with a strong community and many well maintained packages to realize various applications. 

The motivation for this project is to combine the community and possibilities of Python with the convenience of Simulink and the knowledge and work that has been already created in models.
It should be easy to make Simulink Models accessible for Python environments and allow the sharing of these environments with systems that do not have MathWorks software installed.

Many projects that use MatLab and Simulink from another programming environment depend on these software components to be installed and basically running Matlab/Simulink in the background. 

MathWorks provides the possibility of generating C/C++ code and even shared libraries, which can then be used without MathWorks software being installed.
Those shared libraries are far more efficient than running MatLab/Simulink in the background.

_While the export of shared libraries is only possible with the Embedded Coder package, we only need the (cheaper) Simulink Coder package to generate code._

## What is generated?

A set of binaries (for Linux, Mac and Windows) as well as a set of python files. If bundled into a module, it is very easy to
share these with other, as there are no further dependencies besides Python itself.

The binaries represent the Simulink model(s), but not custom calling code written in `.m` files. Workflows that set and read properties
or control the simulation progress are not part of the generated files. After all that's what we aim to do from python. 

## Prerequisites

The generation of the code of the Simulink model obviously needs **Simulink** as well as the **Simulink Coder** plugin.

_Once the code is generated none of the MatLab software is needed anymore._

To run this project [python3](https://www.python.org/downloads/) as well as [pipenv](https://pypi.org/project/pipenv/) is needed. Additionally, [docker](https://docs.docker.com/get-docker/) must be installed to compile the code for multiple platforms.

The python packages that need to be installed should be handled by `pipenv` and the included `Pipfile`.

## Usage

If you do not have the generated code for the Simulink Model you first need to [generate it](#export-code-from-simulink).

Once you have the generated the code further steps can be executed on machines were MatLab/Simulink is not installed.

The zip file that was generated by Matlab should be extracted. 
Down in the file tree there should be a c header file with your project name. (e.g. `myProject.h)
The path to this header file is the first argument. It represents the definition of the system.

A full command would look like this:
```
python3 main.py ~/path/to/header.h outputDirectory -b binaryName -g PythonBindingsName -c
```

`-b binaryName` serves two purposes. When the `-c` (compile) parameter is provided, the model code will be compiled into binaries
with the provided base name. When the `-g PythonBindingsName` parameter is provided, the generated python binding will look for `binaryName` binary
files when initialized.
`-g PythonBindingsName` is also needed to enable the bindings generation, where the given name will be the name of the python class as well as a lower-case variant the file name.

Given this setup it is possible to independently compile the binaries and generate python bindings.

## Export Code from Simulink

In a first step make sure that all the signals, outputs, inputs and parameters have a (unique) descriptive name. This will make it a lot easier to associate them later in the generated model.
It is also the time to decide which signals are relevant and how important certain symbols are, because we should define a [Storage Classes](https://www.mathworks.com/help/rtw/ug/choose-a-built-in-storage-class-for-controlling-data-representation-in-the-generated-code.html) for every 
signal, output, input and parameter we would like to access later through the python bindings. Per default everything that has a user set name, will have the "Model default" Storage Class assigned.

In the `C Code` tab (Top bar `Apps` -> `Simulink Code`) open `Settings`.
![](pictures/c-code-tab.png)
![](pictures/coder-settings.png)

We go through the menus and verify the correct settings:
- `Solver`
  - The `Type` of the `Solver selection` needs to be set to `Fixed step`. The `Solver` can be set to `auto` (or to a specific model if needed). The start and stop time is not relevant.
- `Date Import/Export` 
  - everything should be unchecked.
- `Code Generation`
  - `System target file` should be `grt.tlc` (Generic real-time target)
  - `Language` -> `C`
  - Check `Generate code only`
  - Check `Package code and artifacts` and define a name for the zip file
  - In the submenu `Interface`
    - Go to `Advanced parameters` often only shown as three dots `...` after all the other properties
      - Uncheck `MAT-file logging` (mostly we do not need this feature, SliM-Pyb can also handle it if this keeps checked)

Once everything is set correctly the code can be generated pressing generate code.
![](pictures/generate-code.png)

There should be a zip file in your matlab project folder now. The content is needed to generate the binaries and the python bindings.

### Assigning a Storage Class

There are basically two ways of assigning a Storage Class to a symbol.

#### With Matlab Code
From a Matlab file (`.m`) it is possible to define [Simulink.Parameter](https://www.mathworks.com/help/simulink/slref/simulink.parameter.html). They offer some configurations, but now we are only interested in the `CoderInfo.StorageClass`.

```matlab
variableName = Simulink.Parameter;
variableName.Value = 1;
variableName.CoderInfo.StorageClass = 'SimulinkGlobal';
```

For more information on the available `StorageClasses` visit the Matlab docs: [Storage Classes](https://www.mathworks.com/help/rtw/ug/choose-a-built-in-storage-class-for-controlling-data-representation-in-the-generated-code.html)


#### With GUI

Open your Simulink Model. There in the top bar select `Apps` -> `Simulink Coder`.

![](pictures/simulink-code-gui.png)

Now there should be a new tab in the bottom left of the windows.

![](pictures/code-mappings-tab.png)

There you can browse through the different types and change the Storage Class.

![](pictures/parameters-gui.png)


## References

To showcase the usage of converted Simulink Models, an [example project](https://github.com/matamegger/reinforced-pid-parameter) with a machine learning environment has been created.

## FAQ

#### Why using docker for the compilation?
Apparently cross-platform compiling is not very easy to setup.
To make the usage of this project easier, but still support major platforms a docker image is used.

## Credits
- [eliben/pycparser](https://github.com/eliben/pycparser)
- [dapperfu/Python-Simulink](https://github.com/dapperfu/Python-Simulink)
- [multiarch/crossbuild](https://github.com/multiarch/crossbuild)